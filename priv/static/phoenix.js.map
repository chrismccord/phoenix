{
  "version": 3,
  "sources": ["../../assets/js/phoenix/utils.js", "../../assets/js/phoenix/constants.js", "../../assets/js/phoenix/push.js", "../../assets/js/phoenix/timer.js", "../../assets/js/phoenix/channel.js", "../../assets/js/phoenix/ajax.js", "../../assets/js/phoenix/longpoll.js", "../../assets/js/phoenix/presence.js", "../../assets/js/phoenix/serializer.js", "../../assets/js/phoenix/socket.js"],
  "sourcesContent": ["// wraps value in closure or returns closure\nexport let closure = (value) => {\n  if(typeof value === \"function\"){\n    return value\n  } else {\n    let closure = function (){ return value }\n    return closure\n  }\n}\n", "export const globalSelf = typeof self !== \"undefined\" ? self : null\nexport const phxWindow = typeof window !== \"undefined\" ? window : null\nexport const global = globalSelf || phxWindow || this\nexport const DEFAULT_VSN = \"2.0.0\"\nexport const SOCKET_STATES = {connecting: 0, open: 1, closing: 2, closed: 3}\nexport const DEFAULT_TIMEOUT = 10000\nexport const WS_CLOSE_NORMAL = 1000\nexport const CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\",\n}\nexport const CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n}\nexport const CHANNEL_LIFECYCLE_EVENTS = [\n  CHANNEL_EVENTS.close,\n  CHANNEL_EVENTS.error,\n  CHANNEL_EVENTS.join,\n  CHANNEL_EVENTS.reply,\n  CHANNEL_EVENTS.leave\n]\nexport const TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n}\n", "/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\nexport default class Push {\n  constructor(channel, event, payload, timeout){\n    this.channel = channel\n    this.event = event\n    this.payload = payload || function (){ return {} }\n    this.receivedResp = null\n    this.timeout = timeout\n    this.timeoutTimer = null\n    this.recHooks = []\n    this.sent = false\n  }\n\n  /**\n   *\n   * @param {number} timeout\n   */\n  resend(timeout){\n    this.timeout = timeout\n    this.reset()\n    this.send()\n  }\n\n  /**\n   *\n   */\n  send(){\n    if(this.hasReceived(\"timeout\")){ return }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    })\n  }\n\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n  receive(status, callback){\n    if(this.hasReceived(status)){\n      callback(this.receivedResp.response)\n    }\n\n    this.recHooks.push({status, callback})\n    return this\n  }\n\n  /**\n   * @private\n   */\n  reset(){\n    this.cancelRefEvent()\n    this.ref = null\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n  }\n\n  /**\n   * @private\n   */\n  matchReceive({status, response, _ref}){\n    this.recHooks.filter(h => h.status === status)\n      .forEach(h => h.callback(response))\n  }\n\n  /**\n   * @private\n   */\n  cancelRefEvent(){\n    if(!this.refEvent){ return }\n    this.channel.off(this.refEvent)\n  }\n\n  /**\n   * @private\n   */\n  cancelTimeout(){\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n\n  /**\n   * @private\n   */\n  startTimeout(){\n    if(this.timeoutTimer){ this.cancelTimeout() }\n    this.ref = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent()\n      this.cancelTimeout()\n      this.receivedResp = payload\n      this.matchReceive(payload)\n    })\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {})\n    }, this.timeout)\n  }\n\n  /**\n   * @private\n   */\n  hasReceived(status){\n    return this.receivedResp && this.receivedResp.status === status\n  }\n\n  /**\n   * @private\n   */\n  trigger(status, response){\n    this.channel.trigger(this.refEvent, {status, response})\n  }\n}\n", "/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\nexport default class Timer {\n  constructor(callback, timerCalc){\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset(){\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout(){\n    clearTimeout(this.timer)\n\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n", "import {closure} from \"./utils\"\nimport {\n  CHANNEL_EVENTS,\n  CHANNEL_LIFECYCLE_EVENTS,\n  CHANNEL_STATES,\n} from \"./constants\"\n\nimport Push from \"./push\"\nimport Timer from \"./timer\"\n\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\nexport default class Channel {\n  constructor(topic, params, socket){\n    this.state = CHANNEL_STATES.closed\n    this.topic = topic\n    this.params = closure(params || {})\n    this.socket = socket\n    this.bindings = []\n    this.bindingRef = 0\n    this.timeout = this.socket.timeout\n    this.joinedOnce = false\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\n    this.pushBuffer = []\n    this.stateChangeRefs = []\n\n    this.rejoinTimer = new Timer(() => {\n      if(this.socket.isConnected()){ this.rejoin() }\n    }, this.socket.rejoinAfterMs)\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()))\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\n      this.rejoinTimer.reset()\n      if(this.isErrored()){ this.rejoin() }\n    })\n    )\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach(pushEvent => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError(reason => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason)\n      if(this.isJoining()){ this.joinPush.reset() }\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.joinPush.receive(\"timeout\", () => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout)\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout)\n      leavePush.send()\n      this.state = CHANNEL_STATES.errored\n      this.joinPush.reset()\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  join(timeout = this.timeout){\n    if(this.joinedOnce){\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\")\n    } else {\n      this.timeout = timeout\n      this.joinedOnce = true\n      this.rejoin()\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n  onClose(callback){\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n  onError(callback){\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason))\n  }\n\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n  on(event, callback){\n    let ref = this.bindingRef++\n    this.bindings.push({event, ref, callback})\n    return ref\n  }\n\n  /**\n   * Unsubscribes off of channel events\n   *\n   * Use the ref returned from a channel.on() to unsubscribe one\n   * handler, or pass nothing for the ref to unsubscribe all\n   * handlers for the given event.\n   *\n   * @example\n   * // Unsubscribe the do_stuff handler\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * channel.off(\"event\", ref1)\n   *\n   * // Unsubscribe all handlers from event\n   * channel.off(\"event\")\n   *\n   * @param {string} event\n   * @param {integer} ref\n   */\n  off(event, ref){\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref))\n    })\n  }\n\n  /**\n   * @private\n   */\n  canPush(){ return this.socket.isConnected() && this.isJoined() }\n\n  /**\n   * Sends a message `event` to phoenix with the payload `payload`.\n   * Phoenix receives this in the `handle_in(event, payload, socket)`\n   * function. if phoenix replies or it times out (default 10000ms),\n   * then optionally the reply can be received.\n   *\n   * @example\n   * channel.push(\"event\")\n   *   .receive(\"ok\", payload => console.log(\"phoenix replied:\", payload))\n   *   .receive(\"error\", err => console.log(\"phoenix errored\", err))\n   *   .receive(\"timeout\", () => console.log(\"timed out pushing\"))\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n  push(event, payload, timeout = this.timeout){\n    payload = payload || {}\n    if(!this.joinedOnce){\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`)\n    }\n    let pushEvent = new Push(this, event, function (){ return payload }, timeout)\n    if(this.canPush()){\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  leave(timeout = this.timeout){\n    this.rejoinTimer.reset()\n    this.joinPush.cancelTimeout()\n\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, \"leave\")\n    }\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout)\n    leavePush.receive(\"ok\", () => onClose())\n      .receive(\"timeout\", () => onClose())\n    leavePush.send()\n    if(!this.canPush()){ leavePush.trigger(\"ok\", {}) }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n  onMessage(_event, payload, _ref){ return payload }\n\n  /**\n   * @private\n   */\n  isLifecycleEvent(event){ return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0 }\n\n  /**\n   * @private\n   */\n  isMember(topic, event, payload, joinRef){\n    if(this.topic !== topic){ return false }\n\n    if(joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)){\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {topic, event, payload, joinRef})\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @private\n   */\n  joinRef(){ return this.joinPush.ref }\n\n  /**\n   * @private\n   */\n  rejoin(timeout = this.timeout){\n    if(this.isLeaving()){ return }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /**\n   * @private\n   */\n  trigger(event, payload, ref, joinRef){\n    let handledPayload = this.onMessage(event, payload, ref, joinRef)\n    if(payload && !handledPayload){ throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\") }\n\n    let eventBindings = this.bindings.filter(bind => bind.event === event)\n\n    for(let i = 0; i < eventBindings.length; i++){\n      let bind = eventBindings[i]\n      bind.callback(handledPayload, ref, joinRef || this.joinRef())\n    }\n  }\n\n  /**\n   * @private\n   */\n  replyEventName(ref){ return `chan_reply_${ref}` }\n\n  /**\n   * @private\n   */\n  isClosed(){ return this.state === CHANNEL_STATES.closed }\n\n  /**\n   * @private\n   */\n  isErrored(){ return this.state === CHANNEL_STATES.errored }\n\n  /**\n   * @private\n   */\n  isJoined(){ return this.state === CHANNEL_STATES.joined }\n\n  /**\n   * @private\n   */\n  isJoining(){ return this.state === CHANNEL_STATES.joining }\n\n  /**\n   * @private\n   */\n  isLeaving(){ return this.state === CHANNEL_STATES.leaving }\n}\n", "import {\n  global\n} from \"./constants\"\n\nexport default class Ajax {\n  constructor(){\n    this.states = {complete: 4}\n  }\n\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback){\n    if(global.XDomainRequest){\n      let req = new global.XDomainRequest() // IE8, IE9\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback)\n    } else {\n      let req = new global.XMLHttpRequest() // IE7+, Firefox, Chrome, Opera, Safari\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback)\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback){\n    req.timeout = timeout\n    req.open(method, endPoint)\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText)\n      callback && callback(response)\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => { }\n\n    req.send(body)\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback){\n    req.open(method, endPoint, true)\n    req.timeout = timeout\n    req.setRequestHeader(\"Content-Type\", accept)\n    req.onerror = () => { callback && callback(null) }\n    req.onreadystatechange = () => {\n      if(req.readyState === this.states.complete && callback){\n        let response = this.parseJSON(req.responseText)\n        callback(response)\n      }\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    req.send(body)\n  }\n\n  static parseJSON(resp){\n    if(!resp || resp === \"\"){ return null }\n\n    try {\n      return JSON.parse(resp)\n    } catch (e){\n      console && console.log(\"failed to parse JSON response\", resp)\n      return null\n    }\n  }\n\n  static serialize(obj, parentKey){\n    let queryStr = []\n    for(var key in obj){\n      if(!Object.prototype.hasOwnProperty.call(obj, key)){ continue }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key\n      let paramVal = obj[key]\n      if(typeof paramVal === \"object\"){\n        queryStr.push(this.serialize(paramVal, paramKey))\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal))\n      }\n    }\n    return queryStr.join(\"&\")\n  }\n\n  static appendParams(url, params){\n    if(Object.keys(params).length === 0){ return url }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\"\n    return `${url}${prefix}${this.serialize(params)}`\n  }\n}\n", "import {\n  SOCKET_STATES,\n  TRANSPORTS\n} from \"./constants\"\n\nimport Ajax from \"./ajax\"\n\nexport default class LongPoll {\n\n  constructor(endPoint){\n    this.endPoint = null\n    this.token = null\n    this.skipHeartbeat = true\n    this.onopen = function (){ } // noop\n    this.onerror = function (){ } // noop\n    this.onmessage = function (){ } // noop\n    this.onclose = function (){ } // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint)\n    this.readyState = SOCKET_STATES.connecting\n\n    this.poll()\n  }\n\n  normalizeEndpoint(endPoint){\n    return (endPoint\n      .replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")\n      .replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll))\n  }\n\n  endpointURL(){\n    return Ajax.appendParams(this.pollEndpoint, {token: this.token})\n  }\n\n  closeAndRetry(){\n    this.close()\n    this.readyState = SOCKET_STATES.connecting\n  }\n\n  ontimeout(){\n    this.onerror(\"timeout\")\n    this.closeAndRetry()\n  }\n\n  poll(){\n    if(!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)){ return }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if(resp){\n        var {status, token, messages} = resp\n        this.token = token\n      } else {\n        status = 0\n      }\n\n      switch(status){\n        case 200:\n          messages.forEach(msg => {\n            // Tasks are what things like event handlers, setTimeout callbacks,\n            // promise resolves and more are run within.\n            // In modern browsers, there are two different kinds of tasks,\n            // microtasks and macrotasks.\n            // Microtasks are mainly used for Promises, while macrotasks are\n            // used for everything else.\n            // Microtasks always have priority over macrotasks. If the JS engine\n            // is looking for a task to run, it will always try to empty the\n            // microtask queue before attempting to run anything from the\n            // macrotask queue.\n            //\n            // For the WebSocket transport, messages always arrive in their own\n            // event. This means that if any promises are resolved from within,\n            // their callbacks will always finish execution by the time the\n            // next message event handler is run.\n            //\n            // In order to emulate this behaviour, we need to make sure each\n            // onmessage handler is run within it's own macrotask.\n            setTimeout(() => {\n              this.onmessage({data: msg})\n            }, 0)\n          })\n          this.poll()\n          break\n        case 204:\n          this.poll()\n          break\n        case 410:\n          this.readyState = SOCKET_STATES.open\n          this.onopen()\n          this.poll()\n          break\n        case 403:\n          this.onerror()\n          this.close()\n          break\n        case 0:\n        case 500:\n          this.onerror()\n          this.closeAndRetry()\n          break\n        default: throw new Error(`unhandled poll status ${status}`)\n      }\n    })\n  }\n\n  send(body){\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if(!resp || resp.status !== 200){\n        this.onerror(resp && resp.status)\n        this.closeAndRetry()\n      }\n    })\n  }\n\n  close(_code, _reason){\n    this.readyState = SOCKET_STATES.closed\n    this.onclose()\n  }\n}\n", "/**\n * Initializes the Presence\n * @param {Channel} channel - The Channel\n * @param {Object} opts - The options,\n *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\nexport default class Presence {\n\n  constructor(channel, opts = {}){\n    let events = opts.events || {state: \"presence_state\", diff: \"presence_diff\"}\n    this.state = {}\n    this.pendingDiffs = []\n    this.channel = channel\n    this.joinRef = null\n    this.caller = {\n      onJoin: function (){ },\n      onLeave: function (){ },\n      onSync: function (){ }\n    }\n\n    this.channel.on(events.state, newState => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      this.joinRef = this.channel.joinRef()\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave)\n\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n      })\n      this.pendingDiffs = []\n      onSync()\n    })\n\n    this.channel.on(events.diff, diff => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      if(this.inPendingSyncState()){\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n        onSync()\n      }\n    })\n  }\n\n  onJoin(callback){ this.caller.onJoin = callback }\n\n  onLeave(callback){ this.caller.onLeave = callback }\n\n  onSync(callback){ this.caller.onSync = callback }\n\n  list(by){ return Presence.list(this.state, by) }\n\n  inPendingSyncState(){\n    return !this.joinRef || (this.joinRef !== this.channel.joinRef())\n  }\n\n  // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n  static syncState(currentState, newState, onJoin, onLeave){\n    let state = this.clone(currentState)\n    let joins = {}\n    let leaves = {}\n\n    this.map(state, (key, presence) => {\n      if(!newState[key]){\n        leaves[key] = presence\n      }\n    })\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key]\n      if(currentPresence){\n        let newRefs = newPresence.metas.map(m => m.phx_ref)\n        let curRefs = currentPresence.metas.map(m => m.phx_ref)\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0)\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0)\n        if(joinedMetas.length > 0){\n          joins[key] = newPresence\n          joins[key].metas = joinedMetas\n        }\n        if(leftMetas.length > 0){\n          leaves[key] = this.clone(currentPresence)\n          leaves[key].metas = leftMetas\n        }\n      } else {\n        joins[key] = newPresence\n      }\n    })\n    return this.syncDiff(state, {joins: joins, leaves: leaves}, onJoin, onLeave)\n  }\n\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n  static syncDiff(state, diff, onJoin, onLeave){\n    let {joins, leaves} = this.clone(diff)\n    if(!onJoin){ onJoin = function (){ } }\n    if(!onLeave){ onLeave = function (){ } }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key]\n      state[key] = this.clone(newPresence)\n      if(currentPresence){\n        let joinedRefs = state[key].metas.map(m => m.phx_ref)\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0)\n        state[key].metas.unshift(...curMetas)\n      }\n      onJoin(key, currentPresence, newPresence)\n    })\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key]\n      if(!currentPresence){ return }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref)\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0\n      })\n      onLeave(key, currentPresence, leftPresence)\n      if(currentPresence.metas.length === 0){\n        delete state[key]\n      }\n    })\n    return state\n  }\n\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n  static list(presences, chooser){\n    if(!chooser){ chooser = function (key, pres){ return pres } }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence)\n    })\n  }\n\n  // private\n\n  static map(obj, func){\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]))\n  }\n\n  static clone(obj){ return JSON.parse(JSON.stringify(obj)) }\n}\n", "/* The default serializer for encoding and decoding messages */\nimport {\n  CHANNEL_EVENTS\n} from \"./constants\"\n\nexport default {\n  HEADER_LENGTH: 1,\n  META_LENGTH: 4,\n  KINDS: {push: 0, reply: 1, broadcast: 2},\n\n  encode(msg, callback){\n    if(msg.payload.constructor === ArrayBuffer){\n      return callback(this.binaryEncode(msg))\n    } else {\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload]\n      return callback(JSON.stringify(payload))\n    }\n  },\n\n  decode(rawPayload, callback){\n    if(rawPayload.constructor === ArrayBuffer){\n      return callback(this.binaryDecode(rawPayload))\n    } else {\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload)\n      return callback({join_ref, ref, topic, event, payload})\n    }\n  },\n\n  // private\n\n  binaryEncode(message){\n    let {join_ref, ref, event, topic, payload} = message\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength)\n    let view = new DataView(header)\n    let offset = 0\n\n    view.setUint8(offset++, this.KINDS.push) // kind\n    view.setUint8(offset++, join_ref.length)\n    view.setUint8(offset++, ref.length)\n    view.setUint8(offset++, topic.length)\n    view.setUint8(offset++, event.length)\n    Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)))\n    Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)))\n\n    var combined = new Uint8Array(header.byteLength + payload.byteLength)\n    combined.set(new Uint8Array(header), 0)\n    combined.set(new Uint8Array(payload), header.byteLength)\n\n    return combined.buffer\n  },\n\n  binaryDecode(buffer){\n    let view = new DataView(buffer)\n    let kind = view.getUint8(0)\n    let decoder = new TextDecoder()\n    switch(kind){\n      case this.KINDS.push: return this.decodePush(buffer, view, decoder)\n      case this.KINDS.reply: return this.decodeReply(buffer, view, decoder)\n      case this.KINDS.broadcast: return this.decodeBroadcast(buffer, view, decoder)\n    }\n  },\n\n  decodePush(buffer, view, decoder){\n    let joinRefSize = view.getUint8(1)\n    let topicSize = view.getUint8(2)\n    let eventSize = view.getUint8(3)\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1 // pushes have no ref\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize))\n    offset = offset + joinRefSize\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n    return {join_ref: joinRef, ref: null, topic: topic, event: event, payload: data}\n  },\n\n  decodeReply(buffer, view, decoder){\n    let joinRefSize = view.getUint8(1)\n    let refSize = view.getUint8(2)\n    let topicSize = view.getUint8(3)\n    let eventSize = view.getUint8(4)\n    let offset = this.HEADER_LENGTH + this.META_LENGTH\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize))\n    offset = offset + joinRefSize\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize))\n    offset = offset + refSize\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n    let payload = {status: event, response: data}\n    return {join_ref: joinRef, ref: ref, topic: topic, event: CHANNEL_EVENTS.reply, payload: payload}\n  },\n\n  decodeBroadcast(buffer, view, decoder){\n    let topicSize = view.getUint8(1)\n    let eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    let data = buffer.slice(offset, buffer.byteLength)\n\n    return {join_ref: null, ref: null, topic: topic, event: event, payload: data}\n  }\n}\n", "/** Initializes the Socket *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {Function} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON encoder.\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n * @param {vsn} [opts.vsn] - The serializer's protocol version to send on connect.\n *\n * Defaults to DEFAULT_VSN.\n*/\n\nimport {\n  global,\n  phxWindow,\n  CHANNEL_EVENTS,\n  DEFAULT_TIMEOUT,\n  DEFAULT_VSN,\n  SOCKET_STATES,\n  TRANSPORTS,\n  WS_CLOSE_NORMAL\n} from \"./constants\"\n\nimport {\n  closure\n} from \"./utils\"\n\nimport Ajax from \"./ajax\"\nimport Channel from \"./channel\"\nimport LongPoll from \"./longpoll\"\nimport Serializer from \"./serializer\"\nimport Timer from \"./timer\"\n\nexport default class Socket {\n  constructor(endPoint, opts = {}){\n    this.stateChangeCallbacks = {open: [], close: [], error: [], message: []}\n    this.channels = []\n    this.sendBuffer = []\n    this.ref = 0\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT\n    this.transport = opts.transport || global.WebSocket || LongPoll\n    this.establishedConnections = 0\n    this.defaultEncoder = Serializer.encode.bind(Serializer)\n    this.defaultDecoder = Serializer.decode.bind(Serializer)\n    this.closeWasClean = false\n    this.binaryType = opts.binaryType || \"arraybuffer\"\n    this.connectClock = 1\n    if(this.transport !== LongPoll){\n      this.encode = opts.encode || this.defaultEncoder\n      this.decode = opts.decode || this.defaultDecoder\n    } else {\n      this.encode = this.defaultEncoder\n      this.decode = this.defaultDecoder\n    }\n    let awaitingConnectionOnPageShow = null\n    if(phxWindow && phxWindow.addEventListener){\n      phxWindow.addEventListener(\"pagehide\", _e => {\n        if(this.conn){\n          this.disconnect()\n          awaitingConnectionOnPageShow = this.connectClock\n        }\n      })\n      phxWindow.addEventListener(\"pageshow\", _e => {\n        if(awaitingConnectionOnPageShow === this.connectClock){\n          awaitingConnectionOnPageShow = null\n          this.connect()\n        }\n      })\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000\n    this.rejoinAfterMs = (tries) => {\n      if(opts.rejoinAfterMs){\n        return opts.rejoinAfterMs(tries)\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000\n      }\n    }\n    this.reconnectAfterMs = (tries) => {\n      if(opts.reconnectAfterMs){\n        return opts.reconnectAfterMs(tries)\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n      }\n    }\n    this.logger = opts.logger || null\n    this.longpollerTimeout = opts.longpollerTimeout || 20000\n    this.params = closure(opts.params || {})\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.vsn = opts.vsn || DEFAULT_VSN\n    this.heartbeatTimer = null\n    this.pendingHeartbeatRef = null\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect())\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Disconnects and replaces the active transport\n   *\n   * @param {Function} newTransport - The new transport class to instantiate\n   *\n   */\n  replaceTransport(newTransport){\n    this.disconnect()\n    this.transport = newTransport\n  }\n\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n  protocol(){ return location.protocol.match(/^https/) ? \"wss\" : \"ws\" }\n\n  /**\n   * The fully qualifed socket url\n   *\n   * @returns {string}\n   */\n  endPointURL(){\n    let uri = Ajax.appendParams(\n      Ajax.appendParams(this.endPoint, this.params()), {vsn: this.vsn})\n    if(uri.charAt(0) !== \"/\"){ return uri }\n    if(uri.charAt(1) === \"/\"){ return `${this.protocol()}:${uri}` }\n\n    return `${this.protocol()}://${location.host}${uri}`\n  }\n\n  /**\n   * Disconnects the socket\n   *\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.\n   *\n   * @param {Function} callback - Optional callback which is called after socket is disconnected.\n   * @param {integer} code - A status code for disconnection (Optional).\n   * @param {string} reason - A textual description of the reason to disconnect. (Optional)\n   */\n  disconnect(callback, code, reason){\n    this.connectClock++\n    this.closeWasClean = true\n    this.reconnectTimer.reset()\n    this.teardown(callback, code, reason)\n  }\n\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n  connect(params){\n    this.connectClock++\n    if(params){\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\")\n      this.params = closure(params)\n    }\n    if(this.conn){ return }\n    this.closeWasClean = false\n    this.conn = new this.transport(this.endPointURL())\n    this.conn.binaryType = this.binaryType\n    this.conn.timeout = this.longpollerTimeout\n    this.conn.onopen = () => this.onConnOpen()\n    this.conn.onerror = error => this.onConnError(error)\n    this.conn.onmessage = event => this.onConnMessage(event)\n    this.conn.onclose = event => this.onConnClose(event)\n  }\n\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n  log(kind, msg, data){ this.logger(kind, msg, data) }\n\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n  hasLogger(){ return this.logger !== null }\n\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n  onOpen(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.open.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n  onClose(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.close.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n  onError(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.error.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n  onMessage(callback){\n    let ref = this.makeRef()\n    this.stateChangeCallbacks.message.push([ref, callback])\n    return ref\n  }\n\n  /**\n   * @private\n   */\n  onConnOpen(){\n    if(this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`)\n    this.closeWasClean = false\n    this.establishedConnections++\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.resetHeartbeat()\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback())\n  }\n\n  /**\n   * @private\n   */\n\n  heartbeatTimeout(){\n    if(this.pendingHeartbeatRef){\n      this.pendingHeartbeatRef = null\n      if(this.hasLogger()){ this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\") }\n      this.abnormalClose(\"heartbeat timeout\")\n    }\n  }\n\n  resetHeartbeat(){\n    if(this.conn && this.conn.skipHeartbeat){ return }\n    this.pendingHeartbeatRef = null\n    clearTimeout(this.heartbeatTimer)\n    setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n  }\n\n  teardown(callback, code, reason){\n    if(!this.conn){\n      return callback && callback()\n    }\n\n    this.waitForBufferDone(() => {\n      if(this.conn){\n        if(code){ this.conn.close(code, reason || \"\") } else { this.conn.close() }\n      }\n\n      this.waitForSocketClosed(() => {\n        if(this.conn){\n          this.conn.onclose = function (){ } // noop\n          this.conn = null\n        }\n\n        callback && callback()\n      })\n    })\n  }\n\n  waitForBufferDone(callback, tries = 1){\n    if(tries === 5 || !this.conn || !this.conn.bufferedAmount){\n      callback()\n      return\n    }\n\n    setTimeout(() => {\n      this.waitForBufferDone(callback, tries + 1)\n    }, 150 * tries)\n  }\n\n  waitForSocketClosed(callback, tries = 1){\n    if(tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed){\n      callback()\n      return\n    }\n\n    setTimeout(() => {\n      this.waitForSocketClosed(callback, tries + 1)\n    }, 150 * tries)\n  }\n\n  onConnClose(event){\n    if(this.hasLogger()) this.log(\"transport\", \"close\", event)\n    this.triggerChanError()\n    clearTimeout(this.heartbeatTimer)\n    if(!this.closeWasClean){\n      this.reconnectTimer.scheduleTimeout()\n    }\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event))\n  }\n\n  /**\n   * @private\n   */\n  onConnError(error){\n    if(this.hasLogger()) this.log(\"transport\", error)\n    let transportBefore = this.transport\n    let establishedBefore = this.establishedConnections\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\n      callback(error, transportBefore, establishedBefore)\n    })\n    if(transportBefore === this.transport || establishedBefore > 0){\n      this.triggerChanError()\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerChanError(){\n    this.channels.forEach(channel => {\n      if(!(channel.isErrored() || channel.isLeaving() || channel.isClosed())){\n        channel.trigger(CHANNEL_EVENTS.error)\n      }\n    })\n  }\n\n  /**\n   * @returns {string}\n   */\n  connectionState(){\n    switch(this.conn && this.conn.readyState){\n      case SOCKET_STATES.connecting: return \"connecting\"\n      case SOCKET_STATES.open: return \"open\"\n      case SOCKET_STATES.closing: return \"closing\"\n      default: return \"closed\"\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isConnected(){ return this.connectionState() === \"open\" }\n\n  /**\n   * @private\n   *\n   * @param {Channel}\n   */\n  remove(channel){\n    this.off(channel.stateChangeRefs)\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef())\n  }\n\n  /**\n   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.\n   *\n   * @param {refs} - list of refs returned by calls to\n   *                 `onOpen`, `onClose`, `onError,` and `onMessage`\n   */\n  off(refs){\n    for(let key in this.stateChangeCallbacks){\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n        return refs.indexOf(ref) === -1\n      })\n    }\n  }\n\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n  channel(topic, chanParams = {}){\n    let chan = new Channel(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * @param {Object} data\n   */\n  push(data){\n    if(this.hasLogger()){\n      let {topic, event, payload, ref, join_ref} = data\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload)\n    }\n\n    if(this.isConnected()){\n      this.encode(data, result => this.conn.send(result))\n    } else {\n      this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)))\n    }\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n  makeRef(){\n    let newRef = this.ref + 1\n    if(newRef === this.ref){ this.ref = 0 } else { this.ref = newRef }\n\n    return this.ref.toString()\n  }\n\n  sendHeartbeat(){\n    if(this.pendingHeartbeatRef && !this.isConnected()){ return }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef})\n    this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs)\n  }\n\n  abnormalClose(reason){\n    this.closeWasClean = false\n    if(this.isConnected()){ this.conn.close(WS_CLOSE_NORMAL, reason) }\n  }\n\n  flushSendBuffer(){\n    if(this.isConnected() && this.sendBuffer.length > 0){\n      this.sendBuffer.forEach(callback => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  onConnMessage(rawMessage){\n    this.decode(rawMessage.data, msg => {\n      let {topic, event, payload, ref, join_ref} = msg\n      if(ref && ref === this.pendingHeartbeatRef){\n        clearTimeout(this.heartbeatTimer)\n        this.pendingHeartbeatRef = null\n        setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n      }\n\n      if(this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload)\n\n      for(let i = 0; i < this.channels.length; i++){\n        const channel = this.channels[i]\n        if(!channel.isMember(topic, event, payload, join_ref)){ continue }\n        channel.trigger(event, payload, ref, join_ref)\n      }\n\n      for(let i = 0; i < this.stateChangeCallbacks.message.length; i++){\n        let [, callback] = this.stateChangeCallbacks.message[i]\n        callback(msg)\n      }\n    })\n  }\n\n  leaveOpenTopic(topic){\n    let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()))\n    if(dupChannel){\n      if(this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`)\n      dupChannel.leave()\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
